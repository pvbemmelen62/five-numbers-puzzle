<html>
  <head>
    <script src="Permutations.js"></script>
    <script src="NumberSystem.js"></script>
  </head>
  <body>
    <div id="debugout">
    </div>

    <button onclick="doIt();" >calculate solutions</button>

<script type="text/javascript">
  // [JSDG5] JavaScript: The Definitive Guide, Fifth Edition; by David Flanagan.

  function debug(s) {
    var out = document.getElementById("debugout");
    out.innerHTML += "<br />" + s;
  }
  function assert(condition, message) {
    if(!condition) {
      debug("assert failed: " + message);
      throw new Error("assert failed: " + message);
    }
  }

  /*------------------------------------------------------------------------
    each leaf node holds a number
    each internal nodes holds a binary operators

          8
         / \
        7   4
       / \
      6   3
     / \
    5   2
   / \
  0   1

  let opNodesSpecs = [[5,0,1],[6,5,2],[7,6,3],[8,7,4]];
  --------------------------------------------------------------------------*/

function NumberNode(num) {
  this.num = num;
}
NumberNode.prototype.eval = function() {
  return this.num;
}
NumberNode.prototype.setNum = function(num) {
  this.num = num;
}
NumberNode.prototype._toString = function() {
  return "" + this.num;
}
//--------------------------------------------------
function OperandNode(op, childLeft, childRight) {
  this.op = op;
  this.childLeft = childLeft;
  this.childRight = childRight;
}
OperandNode.prototype.setOp = function(op) {
  this.op = op;
}
OperandNode.prototype.eval = function() {
  let rv = opFuncs[this.op](this.childLeft.eval(), this.childRight.eval());
  return rv;
}
OperandNode.prototype._toString = function() {
  let rv = "(" + this.childLeft._toString() + opSyms[this.op] + this.childRight._toString() + ")";
  return rv;
}

//--------------------------------------------------
let opFuncs = [];
opFuncs[0] = (x,y) => x+y;
opFuncs[1] = (x,y) => x-y;
opFuncs[2] = (x,y) => x*y;
opFuncs[3] = (x,y) => x/y;

let opSyms = [];
opSyms[0] = "+";
opSyms[1] = "-";
opSyms[2] = "*";
opSyms[3] = "/";

/* -----------------------------------------------
  let exprFuncs = [];
  exprFuncs[0] = (fs,ns) => fs[3](fs[2](fs[1](fs[0](ns[0],ns[1]),ns[2]),ns[3]),ns[4]);
  exprFuncs[1] = (fs,ns) => fs[3](fs[2](fs[0](ns[0],ns[1]),fs[1](ns[2],ns[3])),ns[4]);
  exprFuncs[2] = (fs,ns) => fs[3](fs[1](fs[0](ns[0],ns[1]),ns[2]),fs[2](ns[3],ns[4]));
----------------------------------------------- */

let opNodeSpecs = [[5,0,1],[6,5,2],[7,6,3],[8,7,4]];

//--------------------------------------------------
function ExprTree(numNums, opNodeSpecs) {
  this.numNums = numNums;
  this.opNodeSpecs = opNodeSpecs;
  this.numOps = this.opNodeSpecs.length;

  this.nodes = new Array(numNums).fill(null);
  for(let i=0; i<numNums; ++i) {
    this.nodes[i] = new NumberNode(null);
  }
  opNodeSpecs.forEach(spec => {
    this.nodes[spec[0]] = new OperandNode(-1, this.nodes[spec[1]], this.nodes[spec[2]]);
  });
  this.top = this.findTop();
}
ExprTree.prototype.findTop = function() {
  let isChild = new Array(this.numNums + this.numOps).fill(false);
  this.opNodeSpecs.forEach(spec => { isChild[spec[1]] = true; isChild[spec[2]] = true; });
  // check there is only one non-child:
  let isNonChild = isChild.filter(e => !e);
  if(isNonChild.length != 1) throw "Can't find top.";
  //
  let index = isChild.findIndex(e => !e);
  return this.nodes[index];
}
ExprTree.prototype.setOps = function(ops) {
  if(ops.length != this.opNodeSpecs.length) { throw "setOps: wrong argument"; }
  for(let i=0, j=this.numNums; i<ops.length; ++i, ++j) {
    this.nodes[j].setOp(ops[i]);
  }
}
ExprTree.prototype.setNums = function(nums) {
  if(this.numNums != nums.length) { throw "setNums: wrong argument"; }
  for(let i=0; i<nums.length; ++i) {
    this.nodes[i].setNum(nums[i]);
  }
}
ExprTree.prototype.eval = function() {
  let rv = this.top.eval();
  return rv;
}
ExprTree.prototype._toString = function() {
  let rv = this.top._toString();
  return rv;
}

//--------------------------------------------------

  function closeEnough(x,y) {
    let rv = Math.abs(x-y) < 0.001;
    return rv;
  }

  function doIt() {

    let exprTree = new ExprTree(5, opNodeSpecs);

    var numbers = [13,21,23,25,27];
    var numPerms = new Permutations(numbers);
    var count = 0;
    while(numPerms.hasNext()) {
      let numPerm = numPerms.next();
      //
      exprTree.setNums(numPerm);
      //
      let opsIter = new NumberSystem([4,4,4,4]);
      while(opsIter.hasNext()) {
        ++count;
        let ops = opsIter.next();
        //
        exprTree.setOps(ops);
        //
        let val = exprTree.eval();
        if(closeEnough(val, 15)) {
            debug(exprTree._toString());
        }
      }
    }
    debug("count: " + count);
  }
  

</script>
  </body>
</html>
